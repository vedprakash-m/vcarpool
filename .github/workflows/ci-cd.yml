name: vCarpool CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - test
        - prod

env:
  NODE_VERSION: '18.x'
  AZURE_FUNCTIONAPP_NAME: 'vcarpool-api'
  AZURE_STATICWEBAPP_NAME: 'vcarpool-web'
  BACKEND_WORKING_DIR: './backend'
  FRONTEND_WORKING_DIR: './frontend'
  SHARED_WORKING_DIR: './shared'
  INFRASTRUCTURE_WORKING_DIR: './infra'

jobs:
  # Determine deployment environment
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      resource-group: ${{ steps.env.outputs.resource-group }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=test" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          echo "resource-group=vcarpool-rg-${{ steps.env.outputs.environment || 'dev' }}" >> $GITHUB_OUTPUT

  # Build and test shared library
  shared-build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.SHARED_WORKING_DIR }}
    steps:
      - uses: actions/checkout@v4.1.1
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json # Root workspace lock file
      - name: Install dependencies
        run: npm ci
        working-directory: ./ # Install from root for workspace
      - name: Build shared library
        run: npm run build
      - name: Run tests
        run: npm test
        working-directory: ./shared # Run from shared directory
      - name: Upload shared artifacts
        uses: actions/upload-artifact@v4
        with:
          name: shared-dist
          path: ${{ env.SHARED_WORKING_DIR }}/dist

  # Build and test backend
  backend-build:
    needs: shared-build
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.BACKEND_WORKING_DIR }}
    steps:
      - uses: actions/checkout@v4.1.1
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json # Root workspace lock file
      - name: Download shared artifacts
        uses: actions/download-artifact@v4
        with:
          name: shared-dist
          path: ${{ env.SHARED_WORKING_DIR }}/dist
      # Backend's dependencies are installed via workspace root
      - name: Install workspace dependencies
        run: npm ci
        working-directory: ./ # Install from root for workspace
      - name: Lint backend code
        run: npm run lint
      - name: Build backend
        run: npm run build
      - name: Verify environment health
        run: |
          cd ${{ github.workspace }}
          bash scripts/health-check.sh
          
      - name: Run backend tests
        run: |
          # Ensure test directories exist
          mkdir -p coverage
          
          # Run tests with CI reporter
          npm run test:ci
        working-directory: ${{ env.BACKEND_WORKING_DIR }}
      - name: Upload backend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist
          path: ${{ env.BACKEND_WORKING_DIR }}/dist

  # Build and test frontend
  frontend-build:
    needs: shared-build
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
    steps:
      - uses: actions/checkout@v4.1.1
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json # Root workspace lock file
      - name: Download shared artifacts
        uses: actions/download-artifact@v4
        with:
          name: shared-dist
          path: ${{ env.SHARED_WORKING_DIR }}/dist # Places artifact at $GITHUB_WORKSPACE/shared/dist
      # Frontend dependencies are installed via workspace root
      - name: Install workspace dependencies
        run: npm ci
        working-directory: ./ # Install from root for workspace
      - name: Lint frontend code
        run: npm run lint
      - name: Build frontend
        run: npm run build
      - name: Debug - List build output
        run: |
          echo "=== Contents of frontend directory after build ==="
          ls -la
          echo "=== Checking for .next directory ==="
          if [ -d ".next" ]; then
            echo "âœ… .next directory exists"
            ls -la .next/ | head -20
          else
            echo "âŒ .next directory not found"
          fi
          echo "=== Checking for other build outputs ==="
          find . -maxdepth 2 -name "*build*" -o -name "*dist*" -o -name "*out*" 2>/dev/null || echo "No build directories found"
      - name: Run Jest unit tests # Clarified name
        run: npm test
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
      - name: Run Playwright E2E tests
        run: |
          mkdir -p e2e/test-results
          # Retry the E2E tests up to 2 times if they fail
          for i in {1..3}; do
            echo "Attempt $i of 3 running E2E tests"
            if npm run test:e2e:ci; then
              echo "âœ… E2E tests passed"
              break
            else
              echo "âŒ E2E tests failed on attempt $i"
              if [ $i -lt 3 ]; then
                echo "Waiting 30 seconds before retrying..."
                sleep 30
              else
                echo "::error::E2E tests failed after 3 attempts"
                # Don't fail the build on E2E test failures during development, just log the error
                # Remove this condition in production if you want to fail builds on E2E test failures
                if [[ "${{ needs.setup.outputs.environment }}" == "prod" ]]; then
                  exit 1
                fi
              fi
            fi
          done
          echo "::group::Test Summary"
          if [ -f playwright-report/results.json ]; then
            echo "Total Tests: $(jq '.suites[0].specs | length' playwright-report/results.json)"
            echo "Passed: $(jq '.suites[0].specs | map(select(.ok == true)) | length' playwright-report/results.json)"
            echo "Failed: $(jq '.suites[0].specs | map(select(.ok == false)) | length' playwright-report/results.json)"
          else
            echo "No results.json file found. Tests may not have completed."
          fi
          echo "::endgroup::"
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
        env:
          CI: true
      - name: Upload Playwright report
        if: always() # Upload report even if tests fail
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: ${{ env.FRONTEND_WORKING_DIR }}/playwright-report/
          retention-days: 30
      - name: Copy .next directory to dedicated upload directory
        run: |
          echo "Creating a dedicated upload directory for the Next.js build artifacts"
          mkdir -p /tmp/frontend-dist
          cp -r .next/* /tmp/frontend-dist/
          echo "Contents of frontend-dist directory:"
          find /tmp/frontend-dist -type d -maxdepth 2 | sort
          echo "Total files: $(find /tmp/frontend-dist -type f | wc -l)"
      
      - name: Prepare frontend artifacts
        run: |
          echo "=== Preparing frontend artifacts ==="
          # Create a clean directory for the frontend artifacts
          mkdir -p /tmp/frontend-dist/.next
          
          # Copy the build output
          cp -r .next/* /tmp/frontend-dist/.next/
          
          # Copy static files and config
          cp -r public /tmp/frontend-dist/public || true
          cp package.json /tmp/frontend-dist/ || true
          cp next.config.js /tmp/frontend-dist/ || true
          
          # Create or update staticwebapp.config.json
          if [ ! -f "staticwebapp.config.json" ]; then
            echo '{
              "navigationFallback": {
                "rewrite": "/index.html",
                "exclude": ["/images/*", "/*.css", "/*.js", "/*.json"]
              },
              "routes": [
                {
                  "route": "/*",
                  "serve": "/index.html",
                  "statusCode": 200
                }
              ]
            }' > /tmp/frontend-dist/staticwebapp.config.json
          else
            cp staticwebapp.config.json /tmp/frontend-dist/
          fi
          
          echo "=== Frontend artifacts prepared ==="
          find /tmp/frontend-dist -type f | sort
          
      - name: Upload frontend artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-dist
          path: /tmp/frontend-dist/
          retention-days: 1
          if-no-files-found: error

  # Deploy infrastructure
  infrastructure-deploy:
    needs: [setup, shared-build, backend-build, frontend-build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      functionAppName: ${{ steps.deploy.outputs.functionAppName }}
      staticWebAppName: ${{ steps.deploy.outputs.staticWebAppName }}
      functionAppEndpoint: ${{ steps.deploy.outputs.functionAppEndpoint }}
      staticWebAppEndpoint: ${{ steps.deploy.outputs.staticWebAppEndpoint }}
    steps:
      - uses: actions/checkout@v4.1.1
      
      - name: Azure CLI Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Create Resource Group
        run: |
          az group create \
            --name ${{ needs.setup.outputs.resource-group }} \
            --location "East US 2"
      
      - name: Deploy Azure Infrastructure
        id: deploy
        run: |
          cd ${{ env.INFRASTRUCTURE_WORKING_DIR }}
          
          # Deploy Bicep template with improved error handling
          max_attempts=5
          for i in $(seq 1 $max_attempts); do
            echo "Attempting infrastructure deployment (Attempt: $i of $max_attempts)"
            
            if deployment_output=$(az deployment group create \
              --resource-group ${{ needs.setup.outputs.resource-group }} \
              --template-file core-infrastructure.bicep \
              --parameters environmentName=${{ needs.setup.outputs.environment }} \
                          appName=vcarpool \
              --name core-infra-${{ needs.setup.outputs.environment }} \
              --query 'properties.outputs' \
              --output json); then
              echo "âœ… Core infrastructure deployment successful"
              
              # Extract outputs and set as step outputs
              echo "functionAppName=$(echo $deployment_output | jq -r '.functionAppName.value // empty')" >> $GITHUB_OUTPUT
              echo "staticWebAppName=$(echo $deployment_output | jq -r '.staticWebAppName.value // empty')" >> $GITHUB_OUTPUT
              echo "functionAppEndpoint=$(echo $deployment_output | jq -r '.functionAppEndpoint.value // empty')" >> $GITHUB_OUTPUT
              echo "staticWebAppEndpoint=$(echo $deployment_output | jq -r '.staticWebAppEndpoint.value // empty')" >> $GITHUB_OUTPUT
              
              break
            else
              echo "âŒ Deployment attempt $i failed"
              if [ $i -lt 3 ]; then
                echo "Waiting 60 seconds before retrying..."
                sleep 60
              fi
            fi
          done
          
          # Extract outputs and set as step outputs
          echo "functionAppName=$(echo $deployment_output | jq -r '.functionAppName.value // empty')" >> $GITHUB_OUTPUT
          echo "staticWebAppName=$(echo $deployment_output | jq -r '.staticWebAppName.value // empty')" >> $GITHUB_OUTPUT
          echo "functionAppEndpoint=$(echo $deployment_output | jq -r '.functionAppEndpoint.value // empty')" >> $GITHUB_OUTPUT
          echo "staticWebAppEndpoint=$(echo $deployment_output | jq -r '.staticWebAppEndpoint.value // empty')" >> $GITHUB_OUTPUT
          
          echo "Infrastructure deployment completed successfully"
      
      - name: Configure Key Vault Secrets
        run: |
          # Check if Key Vault exists (only for full infrastructure deployments)
          KEY_VAULT_NAME="vcarpool-kv-${{ needs.setup.outputs.environment }}"
          
          if az keyvault show --name $KEY_VAULT_NAME >/dev/null 2>&1; then
            echo "âœ… Key Vault found: $KEY_VAULT_NAME"
            
            # Check if secrets exist, if not create them
            if ! az keyvault secret show --vault-name $KEY_VAULT_NAME --name JWT-SECRET >/dev/null 2>&1; then
              JWT_SECRET=$(openssl rand -base64 64)
              az keyvault secret set --vault-name $KEY_VAULT_NAME --name JWT-SECRET --value "$JWT_SECRET"
            fi
            
            if ! az keyvault secret show --vault-name $KEY_VAULT_NAME --name JWT-REFRESH-SECRET >/dev/null 2>&1; then
              JWT_REFRESH_SECRET=$(openssl rand -base64 64)
              az keyvault secret set --vault-name $KEY_VAULT_NAME --name JWT-REFRESH-SECRET --value "$JWT_REFRESH_SECRET"
            fi
          else
            echo "â„¹ï¸  Key Vault not found: $KEY_VAULT_NAME (using core infrastructure mode with temporary secrets)"
            echo "JWT secrets are configured as Function App environment variables instead"
          fi

  # Deploy backend to Azure Functions
  backend-deploy:
    needs: [setup, infrastructure-deploy]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4.1.1
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Download backend artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-dist
          path: ${{ env.BACKEND_WORKING_DIR }}/dist
      
      - name: Download shared artifacts
        uses: actions/download-artifact@v4
        with:
          name: shared-dist
          path: ${{ env.SHARED_WORKING_DIR }}/dist
      
      - name: Install production dependencies
        working-directory: ${{ env.BACKEND_WORKING_DIR }}
        run: |
          npm ci --production
          # Copy shared library
          cp -r ../${{ env.SHARED_WORKING_DIR }}/dist ./node_modules/@vcarpool/
      
      - name: Azure CLI Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Prepare Function App package
        working-directory: ${{ env.BACKEND_WORKING_DIR }}
        run: |
          # Create a clean directory for the deployment package
          mkdir -p .deploy/functionapp
          
          # Copy all necessary files to the deployment directory
          cp -r dist/* .deploy/functionapp/
          cp -r node_modules .deploy/functionapp/
          cp host.json .deploy/functionapp/
          cp package*.json .deploy/functionapp/
          
          # Create the zip file
          cd .deploy/functionapp
          zip -r ../../functionapp.zip .
          cd ../..
          
          # List the contents of the zip file for debugging
          echo "Contents of the deployment package:"
          unzip -l functionapp.zip | head -20
          
          echo "Function app package created at $(pwd)/functionapp.zip"
          ls -la functionapp.zip
          
      - name: Deploy to Azure Functions using Azure CLI
        working-directory: ${{ env.BACKEND_WORKING_DIR }}
        run: |
          # Install Azure Functions Core Tools
          npm install -g azure-functions-core-tools@4 --unsafe-perm true
          
          # Get the resource group name from the infrastructure deployment
          RESOURCE_GROUP="vcarpool-rg-${{ needs.setup.outputs.environment }}"
          FUNCTION_APP_NAME="${{ needs.infrastructure-deploy.outputs.functionAppName }}"
          
          echo "Deploying to resource group: $RESOURCE_GROUP"
          echo "Function app name: $FUNCTION_APP_NAME"
          
          # List files in the current directory for debugging
          echo "Current directory contents:"
          ls -la
          
          # Verify the zip file exists
          if [ ! -f "functionapp.zip" ]; then
            echo "âŒ functionapp.zip not found in the current directory"
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            exit 1
          fi
          
          echo "Function app package size: $(du -sh functionapp.zip)"
          
          # Deploy the function app using zip deploy
          echo "Starting function app deployment..."
          az functionapp deployment source config-zip \
            --resource-group "$RESOURCE_GROUP" \
            --name "$FUNCTION_APP_NAME" \
            --src functionapp.zip \
            --timeout 600
            
          if [ $? -eq 0 ]; then
            echo "âœ… Function app deployment completed successfully"
          else
            echo "âŒ Function app deployment failed"
            exit 1
          fi
          
      - name: Health Check
        run: |
          echo "Waiting for function app to be available..."
          sleep 30
          endpoint="${{ needs.infrastructure-deploy.outputs.functionAppEndpoint }}"
          if [ ! -z "$endpoint" ]; then
            echo "Testing health endpoint: ${endpoint}/health"
            curl -v -f "${endpoint}/health" || (echo "Health check failed" && exit 1)
          else
            echo "No function app endpoint available"
            exit 1
          fi

  # Deploy frontend to Azure Static Web Apps
  frontend-deploy:
    needs: [setup, infrastructure-deploy, frontend-build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4.1.1
      
      - name: Download frontend artifacts
        uses: actions/download-artifact@v4.1.4
        with:
          name: frontend-dist
          path: ${{ env.FRONTEND_WORKING_DIR }}
          
      - name: Verify downloaded artifacts
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
        run: |
          echo "Verifying downloaded Next.js artifacts"
          if [ -d ".next" ]; then
            echo "âœ… .next directory exists"
            find .next -type d -maxdepth 2 | sort
            echo "Total files: $(find .next -type f | wc -l)"
            
          # Verify static files
          if [ -d "public" ]; then
            echo "âœ… public directory exists"
            ls -la public/
          fi
          
          # Verify configuration files
          if [ -f "next.config.js" ]; then
            echo "âœ… next.config.js exists"
          fi
          
          if [ -f "staticwebapp.config.json" ]; then
            echo "âœ… staticwebapp.config.json exists"
            cat staticwebapp.config.json
          fi
          else
            echo "âŒ .next directory not found"
            ls -la ${{ env.FRONTEND_WORKING_DIR }}
            exit 1
          fi
      
      - name: Verify build output
        working-directory: ${{ env.FRONTEND_WORKING_DIR }}
        run: |
          echo "=== Verifying build output ==="
          if [ ! -d ".next" ]; then
            echo "âŒ .next directory not found in $(pwd)"
            echo "Current directory contents:"
            ls -la
            exit 1
          fi
          
          echo "=== .next directory contents ==="
          find .next -type d | sort
          
          # Ensure staticwebapp.config.json exists
          if [ ! -f "staticwebapp.config.json" ]; then
            echo "âš ï¸ staticwebapp.config.json not found, creating a default one"
            echo '{
              "navigationFallback": {
                "rewrite": "/index.html",
                "exclude": ["/images/*", "/*.css", "/*.js", "/*.json"]
              },
              "routes": [
                {
                  "route": "/*",
                  "serve": "/index.html",
                  "statusCode": 200
                }
              ],
              "mimeTypes": {
                ".json": "text/json"
              }
            }' > staticwebapp.config.json
          fi
          
          # Update API endpoint in config if needed
          FUNCTION_APP_ENDPOINT="${{ needs.infrastructure-deploy.outputs.functionAppEndpoint }}"
          if [ -n "$FUNCTION_APP_ENDPOINT" ]; then
            # Extract hostname without https:// prefix
            API_HOSTNAME=$(echo $FUNCTION_APP_ENDPOINT | sed -e 's|^https://||' -e 's|/.*$||')
            echo "Setting API endpoint to $API_HOSTNAME"
            
            # Create or update environment file
            echo "NEXT_PUBLIC_API_URL=https://$API_HOSTNAME" > .env.production
            
            # Update config file if it exists
            if [ -f "staticwebapp.config.json" ]; then
              sed -i "s|\${API_ENDPOINT}|$API_HOSTNAME|g" staticwebapp.config.json
            fi
            
            echo "=== Updated staticwebapp.config.json ==="
            cat staticwebapp.config.json
          fi
          
      - name: Deploy to Azure Static Web Apps
        uses: Azure/static-web-apps-deploy@v1
        id: swa-deploy
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: 'upload'
          app_location: ${{ env.FRONTEND_WORKING_DIR }}
          output_location: 'out'
          skip_app_build: true
          skip_api_build: true
          verbose: true
          deployment_environment_name: ${{ needs.setup.outputs.environment }}
          env: |
            API_ENDPOINT=${{ needs.infrastructure-deploy.outputs.functionAppEndpoint }}
        continue-on-error: false
        
      - name: Verify deployment
        if: steps.swa-deploy.outcome != 'success'
        run: |
          echo "Deployment failed. Checking logs..."
          # Add any additional verification steps here
          exit 1

  # Post-deployment tests
  integration-tests:
    needs: [setup, infrastructure-deploy, backend-deploy, frontend-deploy]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4.1.1
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Install test dependencies
        working-directory: ${{ env.BACKEND_WORKING_DIR }}
        run: npm ci
      
      - name: Run integration tests
        working-directory: ${{ env.BACKEND_WORKING_DIR }}
        env:
          API_BASE_URL: ${{ needs.infrastructure-deploy.outputs.functionAppEndpoint }}
          FRONTEND_URL: ${{ needs.infrastructure-deploy.outputs.staticWebAppEndpoint }}
        run: |
          if npm run test:integration; then
            echo "âœ… Integration tests passed"
          else
            echo "âŒ Integration tests failed"
            exit 1
          fi

  # Notify deployment status
  notify:
    needs: [setup, infrastructure-deploy, backend-deploy, frontend-deploy, integration-tests]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Deployment Summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ needs.setup.outputs.resource-group }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend API**: ${{ needs.infrastructure-deploy.outputs.functionAppEndpoint }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend App**: ${{ needs.infrastructure-deploy.outputs.staticWebAppEndpoint }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Infrastructure**: ${{ needs.infrastructure-deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend**: ${{ needs.backend-deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend**: ${{ needs.frontend-deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests**: ${{ needs.integration-tests.result }}" >> $GITHUB_STEP_SUMMARY
